#ifndef READER_HPP_NJ1QT0 // "_NJ1QT0" autogenerated for uniqueness
#define READER_HPP_NJ1QT0
#include <istream>
#include <string>
#include <stdexcept>

#include "RoutingSolver.hpp"

struct ParseError: public std::runtime_error {
	ParseError(const std::string &msg)
	: std::runtime_error(msg) 
	{ }
};

/// Reads a RoutingSolver (use once, then discard)
/// Prefer using the convenience function, readRoutingInst(std::istream &),
/// over using this class directly.
struct Reader {
	enum TokenType {
		KWGrid, KWCapacity, KWNum, KWNet, 
		TNetName,
		TInteger,
		TInvalid
	};

private:
	std::istream &in;
	std::string token; ///< Text of last read token
	TokenType tokenType; ///< Token type of last read token
	bool putback; 
	int intValue; ///< Integer value of last read token (if applicable)
	int lineNum;  ///< Current line number

	void skipSpace(); ///< Skip whitespace, incrementing line number if appropriate
	void readNextToken(); ///< Read a token if !putback, otherwise set putback=false
	void unread() { putback = true; } ///< Set putback=true (see readNextToken)
	void expectValid(); ///< Expect any valid token
	void expect(TokenType); ///< Expect a token of the given type
	void unexpected(); ///< Throw an "unexpected token" error

	void emitMessage(const std::string &msg); ///< Emit a non-fatal message with the current line number
	void fail(const std::string &msg); ///< Throw an error with the current line number

	Point readPoint();
	Net readNet();
public:

	Reader(std::istream &in)
	: in(in)
	, putback(false)
	, lineNum(1)
	{ }

	RoutingSolver readRoutingInst();
};

/// Convenience API for Reader
inline RoutingSolver readRoutingInst(std::istream &in)
{
	return Reader(in).readRoutingInst();
}


#endif // READER_HPP_NJ1QT0